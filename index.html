<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>uMQTT: uMQTT Client Package</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">uMQTT
   </div>
   <div id="projectbrief">MQTT client library for microcontrollers</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">uMQTT Client Package </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is called <em>uMQTT</em> or <b>umqtt</b> for "micro-MQTT". The <em>micro</em> refers to microcontroller.</p>
<hr/>
<p>This library provides a set of functions for processing MQTT client packets. It is intended primarily for use with microcontrollers.</p>
<p>The design goals:</p><ul>
<li>written to be portable, not targeting any specific platform</li>
<li>completely isolate the packet processing from packet transmission and reception</li>
<li>not dependent on any particular RTOS, does not require RTOS but could be used with one</li>
<li>not tied to any particular networking hardware or stack</li>
<li>have well documented, consistent and understandable API</li>
</ul>
<p>The library uses instance handles so the same code can be used for multiple client connections to one or more MQTT servers.</p>
<p><b>License</b></p>
<p>BSD-style license, see here <a class="el" href="license.html">License</a>.</p>
<p><b>Application Interface</b></p>
<p><a class="el" href="group__umqtt__api.html">Link to API docs</a></p>
<p><code>umqtt</code> provides a straightforward set of functions for MQTT operations such as Connect, Publish, Subscribe, etc. Internally it keeps track of the state of communication flow so that it can resend packets when needed and know when requests have been properly acknowledged. To do this it provides a <code>Run</code> function that must be called from the application main loop. The application only needs to provide a millisecond tick timer and the <code>umqtt</code> library will keep track of all timeouts.</p>
<p><code>umqtt</code> does require some services from the application. The application must provide functions to read and write from the network, and functions to allocate and free memory. The concept of the network is completely abstract. From the point of view of <code>umqtt</code> library, it is just a data pipe. It could be wired or wireless ethernet, or it could be a serial link. Anything that can be used to transmit and receive data packets. The memory allocator can also be implemented in many ways. The <code>umatt</code> library only needs to receive memory it requests for holding packets. It doesn't matter how the memory is allocated. It could just be a mapping to the run-time <em>malloc()/free()</em> library functions. Or it could be a third party allocator such as <a href="http://www.fourmilab.ch/bget/">bget</a>, or even just a simple list of fixed size buffers.</p>
<p><code>umqtt</code> notifies the application of events with a set of optional callback functions. It is possible to use <code>umqtt</code> without any callback functions.</p>
<p><b>RTOS and thread safety</b></p>
<p>It should be possible to use <code>umqtt</code> with an RTOS. However the API functions have not been written to be thread-safe. If used with an RTOS, either all the functions should be called from within a single RTOS thread, or the API functions should be wrapped with a semaphore to serialize access. None of the API functions are inherently blocking, although they do call the application-supplied network functions and these should be implemented to also be non-blocking.</p>
<p><b>Network Management</b></p>
<p><code>umqtt</code> is implemented to be completely network-agnostic. It is up to the application to provide the interface network. This means that for a typical TCP/IP network, the application must first establish the network socket connection to an MQTT server, before calling <a class="el" href="group__umqtt__api.html#gae9a94c97eefa8711d10ea5ff41b5849c" title="Initiate MQTT protocol Connect. ">umqtt_Connect()</a>.</p>
<p><b>Dynamic memory usage</b></p>
<p>Because MQTT protocol uses an acknowledgment packet flow, it requires that the client track packets that have not been acknowledged and resend unacknowledged packets. Even if QoS 0 is used for published topics, the client still needs to keep track of acks for connect, subscribe, and unsubscribe packets. <code>umqtt</code> does not make any attempts to throttle the number of pending packets. It adds pending packets to an internal linked list. When the appropriate ack packet is received from the network it removes the pending packet from the list and frees it. If the application were to perform many requests at once (multiple subscribes, or publish many topics with QoS 1) then the number of pending packets could momentarily grow large until all of the ack packets are received back from the broker.</p>
<p><code>umqtt</code> also allocates memory to hold instance data when <a class="el" href="group__umqtt__api.html#gae616c0381b1752a036e9322a7fcc6922" title="Create and initialize a umqtt client instance. ">umqtt_New()</a> is called. Therefore, <a class="el" href="group__umqtt__api.html#ga11ca938958786580b20364192e20156c" title="Clean up and free umqtt client instance. ">umqtt_Delete()</a> should always be called if the client is to be shut down.</p>
<p><b>Typical Flow</b></p>
<ul>
<li>application initializes</li>
<li>calls <a class="el" href="group__umqtt__api.html#gae616c0381b1752a036e9322a7fcc6922" title="Create and initialize a umqtt client instance. ">umqtt_New()</a> to set up an instance of umqtt client</li>
<li>establishes a network connection to a MQTT server</li>
<li>calls <a class="el" href="group__umqtt__api.html#gae9a94c97eefa8711d10ea5ff41b5849c" title="Initiate MQTT protocol Connect. ">umqtt_Connect()</a> to establish MQTT client protocol</li>
<li>calls <a class="el" href="group__umqtt__api.html#gac66e219c2735186b5c2afb7ff753de6a" title="Main loop processing for the umqtt client instance. ">umqtt_Run()</a> from the main loop</li>
<li>wait for Connack callback, or until <a class="el" href="group__umqtt__api.html#ga3cb230dbd2737e18b7b1ec454497df3c" title="Get the status of the connection. ">umqtt_GetConnectedStatus()</a> returns UMQTT_ERR_CONNECTED</li>
<li>calls <a class="el" href="group__umqtt__api.html#ga2a3023f26a715c8d0435f31616630b77" title="Subscribe to topics. ">umqtt_Subscribe()</a> to be subscribe to MQTT topics</li>
<li>calls <a class="el" href="group__umqtt__api.html#ga42af6bf8d61c0c3e3c56397fde99c73c" title="Send MQTT protocol Publish packet. ">umqtt_Publish()</a> to publish a topic to MQTT server</li>
<li>calls <a class="el" href="group__umqtt__api.html#ga3a3c80101e4e166fe2af31a4a74ad67a" title="Disconnect MQTT protocol. ">umqtt_Disconnect()</a> to cleanly disconnect protocol</li>
<li>calls <a class="el" href="group__umqtt__api.html#ga11ca938958786580b20364192e20156c" title="Clean up and free umqtt client instance. ">umqtt_Delete()</a> to clean up and free <code>umqtt</code> instance</li>
<li>gets notified of subscribed topics via <a class="el" href="group__umqtt__api.html#ga6304d181e04089265cd9c9f3aca76d4d" title="Callback function for Publish packets. ">PublishCb_t()</a> callback function</li>
</ul>
<p><b>Error Recovery</b></p>
<p><code>umqtt</code> uses a simple minded scheme for tracking network errors and recovering. If any network read or write fails, <code>umqtt</code> will abort the current operation and return UMQTT_ERR_NETWORK error code. It does not otherwise change any internal state. In case it is possible to recover the network connection, the application can perform recovery steps and resume using the <code>umqtt</code> instance and everything should continue as before. But usually if network read or write fails, it means that the connection has been dropped or has some other problem. In this case the recovery procedure should be:</p>
<ul>
<li>application detects network error with UMQTT_ERR_NETWORK return code</li>
<li>calls <a class="el" href="group__umqtt__api.html#ga3a3c80101e4e166fe2af31a4a74ad67a" title="Disconnect MQTT protocol. ">umqtt_Disconnect()</a> to clean up the MQTT client connection (note, this may return another network error but should still be called)</li>
<li>perform network disconnection and cleanup steps</li>
<li>call <a class="el" href="group__umqtt__api.html#ga11ca938958786580b20364192e20156c" title="Clean up and free umqtt client instance. ">umqtt_Delete()</a> to clean up and free the client instance</li>
<li>repeat original steps from beginning to establish network connection, initialize <code>umqtt</code> instance and connect the MQTT client</li>
</ul>
<p>These steps may seem tedious, but it ensures that the MQTT client is disconnected cleanly at the protocol level (if possible) and that all allocated memory is freed. Since <code>umqtt</code> allocates memory to store packets, this procedure ensures that any pending packets that are still allocated will be freed and thus avoid memory leaks due to network errors. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Fri Sep 22 2017 22:49:25 for uMQTT by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
